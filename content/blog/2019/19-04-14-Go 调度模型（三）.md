---
title: Go 调度模型（三）

date: 2019-04-14

author: 付辉
---

> `别抱怨，也别自怜，所有的现状都是你自己选择的`

前面的章节中，我们介绍了操作系统的调度模型：`N:1`、`1:1`、`M:N`。而`Go`采用了更高效的方式`M:N`。从进程的角度来说，线程是最小的调度单元。而`Go`的模型下，可以把`P`作为最小单元的调度单元，即在单个线程上运行的`Go`代码。

## 执行模型

下图展示了`Go`的最小调度单元模型。其中的有两个线程，各维持一个`P`对象，而且正在执行一个`G`代码。为了运行`G`，`M`必须首先持有`P`对象。图中灰色的`G`表示还没有被执行，等待被调度。它们被组织在`P`的一个`runqueues`的队列中，当`M`创建新的`Goroutine`时，对应的`G`就会被追加到该队列的末尾。

![](http://morsmachine.dk/in-motion.jpg)

## 阻塞模型

为什么要引入`P`结构，直接将`runqueues`放在`M`中，不就可以摆脱`P`了吗？当然不行，它存在的意义还在于：当`M`因为其他原因被阻塞时，我们需要将`runqueues`中的`G`交给别的`M`来继续处理。因为线程不可能既执行代码，又阻塞在系统上。

![](https://i.loli.net/2019/04/14/5cb34717549c3.jpg)

如上图所示，当`M0`阻塞在系统调用上时，它会放弃自己的`P`，以保证`M1`可以继续执行其他`G`。当`M0`系统调用返回时，`M0`为了继续执行`G0`，就必须尝试重新获取`P`对象。正常的执行流程是：它尝试去偷其它线程的`P`，如果不行，就将`G0`放到全局的`runqueues`中，之后进入休眠。

当`P`本地的`runqueues`运行完之后，`M`会去全局队列取`G`来执行。同时，全局队列的`G`也会被间歇性检查，否则里面的`G`可能永远都得不到执行了。

## 偷`G`模型

当`runqueues`分布不均衡时，可能存在其中一个`M`执行完了本地的`P`，而其他`P`的本地队列还有很多`G`等待被执行。如图所示，为了去继续运行`Go`代码，`P1`首先会尝试去全局队列获取。如果全局队列没有，那么它就会随机从别的`P`去偷一半回来。这样做也是用来保证所有线程都一直有工作可以做。

![](https://i.loli.net/2019/04/14/5cb34b150acc2.jpg)

参考文章：

1. [`The Go scheduler`](http://morsmachine.dk/go-scheduler) 
